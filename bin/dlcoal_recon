#!/usr/bin/env python
# DLCoal Reconciliation

import sys
import time
import random
from os.path import dirname
import optparse

# import dlcoal library
try:
    import dlcoal
except ImportError:
    sys.path.append(dirname(dirname(sys.argv[0])))
    import dlcoal

import dlcoal.recon

# import rasmus, compbio libs
from rasmus import util,  treelib
from compbio import phylo, birthdeath


#=============================================================================
# options

o = optparse.OptionParser()
o.add_option("-s", "--stree", dest="stree", metavar="SPECIES_TREE")
o.add_option("-S", "--smap", dest="smap", metavar="GENE_TO_SPECIES_MAP")
o.add_option("-n", "--popsize", dest="popsize", metavar="POPULATION_SIZE",
             type="float")
o.add_option("-D", "--duprate", dest="duprate", metavar="DUPLICATION_RATE",
             type="float")
o.add_option("-L", "--lossrate", dest="lossrate", metavar="LOSS_RATE",
             type="float")
o.add_option("-g", "--gentime", dest="gentime", metavar="GENRATION_TIME",
             type="float")
o.add_option("-i", "--iter", dest="iter", metavar="ITERATIONS",
             type="int", default=10)
o.add_option("-I", "--inext", dest="inext", metavar="INPUT_EXT",
             default="")
o.add_option("-O", "--outext", dest="outext", metavar="OUTPUT_EXT",
             default=".dlcoal")
o.add_option("-l", "--log", dest="log", metavar="LOG_FILE")


g = optparse.OptionGroup(o, "Miscellaneous")
o.add_option_group(g)
g.add_option("", "--nsamples", dest="nsamples", metavar="NUM_SAMPLES",
             type="int", default=100)
g.add_option("", "--nprescreen", dest="nprescreen", metavar="NUM_PRESCREENS",
             type="int", default=20)
g.add_option("-x", "--seed", dest="seed", metavar="RANDOM_SEED",
             type="int", default=None)


conf, args = o.parse_args()

if len(args) == 0:
    o.print_help()
    sys.exit(1)

#=============================================================================

def check_tree(tree, name=""):

    for node in tree:
        if len(node.children) not in (0, 2):
            raise Exception("tree is not binary: %s" % name)


#=============================================================================
# read inputs
treefile = args[0]
stree = treelib.read_tree(conf.stree)
smap = phylo.read_gene2species(conf.smap)

# convert species tree into generations
#for node in stree:
#    node.dist *= 1e6 / conf.gentime
#duprate = conf.duprate / (1e6 / conf.gentime)
#lossrate = conf.lossrate / (1e6 / conf.gentime)
#times = treelib.get_tree_timestamps(stree)

#for node in stree:
#    node.dist *= 1e6 / conf.gentime
duprate = conf.duprate# / (1e6 / conf.gentime)
lossrate = conf.lossrate# / (1e6 / conf.gentime)
times = treelib.get_tree_timestamps(stree)


# get popsizes
#  NOTE: popsize is multiplied by 2 to account for diploid species
if conf.popsize is None:
    # scale popsizes by generation time
    popsizes = {}
    for node in stree:
        popsizes[node.name] = (2 * float(node.data["pop"]) *
                               float(node.data["g"]) / 1e6)
else:
    popsizes = 2 * conf.popsize * conf.gentime / 1e6


# start logging
if conf.log:
    log_out = open(conf.log, "w")
else:
    log_out = open(
        util.replace_ext(treefile, conf.inext, conf.outext + ".log"), "w")

# set random seed
if conf.seed is None:
    conf.seed = int(time.time() * 100)
random.seed(conf.seed)
if dlcoal.dlcoalc:
    dlcoal.dlcoalc.srand(conf.seed)
log_out.write("seed: %d\n" % conf.seed)


# read and prepare coal_tree
coal_trees = list(treelib.iter_trees(treefile))
locus_trees = []

for coal_tree in coal_trees:
    check_tree(coal_tree, treefile)

    # remove bootstraps if they exist
    for node in coal_tree:
        if "boot" in node.data:
            del node.data["boot"]
    coal_tree.default_data.clear()


    # perform reconciliation
    maxrecon = dlcoal.recon.dlcoal_recon(
        coal_tree, stree, smap, popsizes, duprate, lossrate,
        premean=.5 * times[stree.root],
        nsamples=conf.nsamples, nprescreen=conf.nprescreen,
        nsearch=conf.iter, log=log_out)
    locus_trees.append(maxrecon["locus_tree"])


# make "consensus" reconciliation if multiple coal trees given
if len(coal_trees) > 1:
    # make consensus locus tree
    coal_tree = phylo.consensus_majority_rule(coal_trees, rooted=True)
    phylo.ensure_binary_tree(coal_tree)
    locus_tree = phylo.consensus_majority_rule(locus_trees, rooted=True)
    phylo.ensure_binary_tree(locus_tree)
    locus_recon = phylo.reconcile(locus_tree, stree, smap)
    maxrecon = {
        "coal_recon": phylo.reconcile(coal_tree, locus_tree, lambda x:x),
        "locus_tree": locus_tree,
        "locus_recon": locus_recon,
        "locus_events": phylo.label_events(locus_tree, locus_recon)}
    maxrecon["daughters"] = dlcoal.recon.propose_daughters(
        coal_tree, maxrecon["coal_recon"], locus_tree,
        maxrecon["locus_events"])


# write outputs
out = util.replace_ext(treefile, conf.inext, conf.outext)
dlcoal.write_dlcoal_recon(out, coal_tree, maxrecon)



'''
coal_tree = treelib.read_tree(treefile)
check_tree(coal_tree, treefile)

# remove bootstraps if they exist
for node in coal_tree:
    if "boot" in node.data:
        del node.data["boot"]
coal_tree.default_data.clear()


# perform reconciliation
maxrecon = dlcoal.recon.dlcoal_recon(
    coal_tree, stree, smap, popsizes, duprate, lossrate,
    premean=.5 * times[stree.root],
    nsamples=conf.nsamples, nprescreen=conf.nprescreen,
    nsearch=conf.iter, log=log_out)

# write outputs
out = util.replace_ext(treefile, conf.inext, conf.outext)
dlcoal.write_dlcoal_recon(out, coal_tree, maxrecon)
'''
